<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <!--sound effect and sound background-->
    <audio id="BbShark" src="bbsharkInstrumental.mp3" loop></audio>
    <audio id="ngum" src="ngum.mp3"></audio>
    <audio id="timeoutS" src="timeout.mp3"></audio>
    <audio id="gameO" src="gameover.mp3"></audio>
    <!--title and favicon-->
    <title>Purple Gingers</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
    
    <style type="text/css">
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      html,
      body {
        height: 100%;
        margin: 0;
      }

      #c {
        width: 100%;
        height: 100%;
        display: block;
      }

      #timer {
        font-family: "Press Start 2P", cursive;
        text-align: center;
        font-size: 65px;
        position: absolute;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        color: aliceblue;
        -webkit-text-stroke: 2px #000000;
      }

      .popup {
        font-family: "Press Start 2P", cursive;
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #f45c5c8f;
        padding: 70px;
        font-size: 65px;
        color: rgb(255, 255, 255);
        border-radius: 20px;
        z-index: 9999;
        text-align: center;
      }

      .gui-container {
        position: absolute;
        top: 0;
        right: 0;
        margin: 10px;
        z-index: 1;
      }

      .heart-icons {
        display: flex;
        align-items: center;
        margin-top: 22px;
      }

      .heart-icon {
        width: 21px;
        height: 20px;
        background: url("https://i.pinimg.com/originals/93/27/c7/9327c75c610c9a82c74b23eac974dbe6.png")
          no-repeat center center;
        background-size: contain;
        margin-right: 3px;
        transition: background-size 0.3s;
      }

      /*Space between hearts */
      .heart-icon:last-child {
        margin-right: 10px;
      }
    </style>
  </head>

  <body>
    <canvas id="c"></canvas>
    <div class="gui-container">
      <!-- Add your heart icon here -->
      <div class="heart-icons">
        <div class="heart-icon"></div>
        <div class="heart-icon"></div>
        <div class="heart-icon"></div>
      </div>
      <div id="gui-container"></div>
    </div>
    <div id="timer">PURPLE GINGERS</div>
    <!--แก้ตามเวลา-->
    <div class="popup" id="gameOverPopup">
      <p>GAME OVER</p>
    </div>
  </body>

  <script type="module">
    import * as THREE from "https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js";
    import { GLTFLoader } from "https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/loaders/GLTFLoader.js";
    import { GUI } from "https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js";
    import {
      MeshPhongMaterial,
      TextureLoader,
    } from "https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js";

    function main() {
      const canvas = document.querySelector("#c");
      const renderer = new THREE.WebGLRenderer({ canvas });
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const popup = document.getElementById("gameOverPopup"); //game over popup
      const BbShark = document.getElementById("BbShark"); //background music
      const timeoutS = document.getElementById("timeoutS"); //time out sound effect
      const gameO = document.getElementById("gameO"); //game over sound effect
      const sound = document.getElementById("ngum"); //eating sound effect

      BbShark.playbackRate = 1.9; //turn up background music

      //camera setting
      const fov = 45;
      const aspect = 2; // the canvas default
      const near = 0.1;
      const far = 100;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

      const scene = new THREE.Scene();

      const textureLoader = new THREE.TextureLoader();
      //import backgroung image
      const backgroundImage = textureLoader.load(
        "https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/7cd3f552-bb67-410f-84f2-3f581a66db86/de73wrn-cede53b5-df6d-4ae0-9272-d45f3b942ed2.jpg/v1/fill/w_1920,h_1059,q_75,strp/underwater_city_by_annemaria48_de73wrn-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTA1OSIsInBhdGgiOiJcL2ZcLzdjZDNmNTUyLWJiNjctNDEwZi04NGYyLTNmNTgxYTY2ZGI4NlwvZGU3M3dybi1jZWRlNTNiNS1kZjZkLTRhZTAtOTI3Mi1kNDVmM2I5NDJlZDIuanBnIiwid2lkdGgiOiI8PTE5MjAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.qE_IFOxhsjrkuO_ahip7lHZ_VGI3KmLwX6jTVO4pdRw"
      ); // URL of your background image
      scene.background = backgroundImage;

      //right front point light
      const studioLight1 = new THREE.PointLight(0xffffff, 0.5);
      studioLight1.position.set(15, 31, 15);
      studioLight1.castShadow = true;
      studioLight1.shadow.bias = -0.001;
      scene.add(studioLight1);
      //back point light
      const studioLight2 = new THREE.PointLight(0xffffff, 1.2);
      studioLight2.position.set(-1, 35, -15);
      studioLight2.castShadow = true; //Can cast shadow 
      studioLight2.shadow.mapSize.width = 2048; //Improve shadow sharpness
      studioLight2.shadow.mapSize.height = 2048; 
      studioLight2.shadow.bias = -0.001; //Improve bias
      scene.add(studioLight2);
      //left front point light
      const studioLight3 = new THREE.PointLight(0xffffff, 0.5);
      studioLight3.position.set(-22, 40, 10);
      studioLight3.castShadow = true;
      studioLight3.shadow.bias = -0.001;
      scene.add(studioLight3);

      // Add AmbientLight
      {
        const color = 0x404040;
        const intensity = 1.5;
        const ambientLight = new THREE.AmbientLight(color, intensity);
        scene.add(ambientLight);
      }

      //camera setting
      function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
        const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
        const halfFovY = THREE.MathUtils.degToRad(camera.fov * 0.5);
        const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);

        // compute a unit vector that points in the direction the camera is now
        // in the xz plane from the center of the box
        const direction = new THREE.Vector3(0, 0, -1);

        // move the camera to a position distance units way from the center
        // in whatever direction the camera was from the center already
        camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

        // pick some near and far values for the frustum that
        // will contain the box.
        camera.near = boxSize / 100;
        camera.far = boxSize * 100;

        camera.updateProjectionMatrix();

        // point the camera to look at the center of the box
        camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
      }

      // Fixed positions for axolotl and jellyfish
      const fixedPositionsAxolotl = [
        new THREE.Vector3(-6, 7.5, -14.5),
        new THREE.Vector3(-3, 7.5, -14.5),
        new THREE.Vector3(0, 7.5, -14.5),
        new THREE.Vector3(-6, 7.5, -11.5),
        new THREE.Vector3(-3, 7.5, -11.5),
        new THREE.Vector3(0, 7.5, -11.5),
        new THREE.Vector3(-6, 7.5, -8.5),
        new THREE.Vector3(-3, 7.5, -8.5),
        new THREE.Vector3(0, 7.5, -8.5),
      ];

      const fixedPositionsJellyfish = [
        new THREE.Vector3(-6, 5, -5.5),
        new THREE.Vector3(-3, 5, -5.5),
        new THREE.Vector3(0, 5, -5.5),
        new THREE.Vector3(-6, 5, -2.5),
        new THREE.Vector3(-3, 5, -2.5),
        new THREE.Vector3(0, 5, -2.5),
        new THREE.Vector3(-6, 5, -0.5),
        new THREE.Vector3(-3, 5, -0.5),
        new THREE.Vector3(0, 5, -0.5),
      ];
      //declare variables
      let axolotl;
      let jellyfish;
      let hand; //right shark
      let board;
      let shark_ham_1; //hitting shark
      let score = 0;
      let heart = 3;
      let stop = false;
      let timeInSeconds = 16 ;

      //function for eating sound effect
      function playSound() {
        sound.currentTime = 0; // เล่นเสียงใหม่ทุกครั้งที่คลิก
        sound.play(); // เล่นเสียง
      }

      function stopAll() {
        stop = true;
        score = 0;
        heart = 3;

        // Pause BbShark and reset its currentTime
        BbShark.pause();
        BbShark.currentTime = 0;
      }

      //reset heart and score
      function resetHearts() {
        guiParams.heart = heart;
        guiParams.score = score;

        // Reset heart icons
        const heartIcons = document.querySelectorAll(".heart-icon");
        heartIcons.forEach((heartIcon, index) => {
          heartIcon.style.backgroundImage =
            "url(https://i.pinimg.com/originals/93/27/c7/9327c75c610c9a82c74b23eac974dbe6.png)";
          heartIcon.style.backgroundSize = "contain";
        });
      }

      //show score, heart, and start button
      const gui = new GUI();
      const guiParams = {
        score: 0,
        heart: 3,
        start: () => {
          popup.style.display = "none"; //hide game over popup when click start
          stop = false;
          hand.visible = true;
          score = 0;
          heart = 3;
          resetHearts();

          BbShark.play();
          BbShark.currentTime = 0;

          countdownTimer(timeInSeconds);

          //pause time out and game over sounds before starting
          timeoutS.pause();
          gameO.pause();
        },
      };

      //show score, heart, and start button
      gui.add(guiParams, "score").name("Score").listen();
      gui.add(guiParams, "heart").name("Hearts").listen();
      gui.add(guiParams, "start").name("Start");

      stopAll(); //set score before starting

      let timerInterval; //declare timerInterval variable

      //function for count down
      function countdownTimer(seconds) {
        clearInterval(timerInterval); //clear time

        timerInterval = setInterval(function () {
          //clear time when game over
          if (stop) {
            clearInterval(timerInterval);
            stopAll(); // Reset the game when the timer ends
            return;
          }

          seconds--;

          let mins = Math.floor(seconds / 60);
          let secs = seconds % 60;

          mins = mins < 10 ? "0" + mins : mins;
          secs = secs < 10 ? "0" + secs : secs;

          let displayTimer = mins + ":" + secs;
          document.getElementById("timer").textContent = displayTimer;

          //time out
          if (seconds === 0) {
            clearInterval(timerInterval); //clear time when time out
            document.getElementById("timer").textContent = "TIME OUT!";
            stop = true; //set stop as true when time out
            BbShark.pause();
            timeoutS.currentTime = 0; //reset the currentTime for time out sound
            timeoutS.play(); //play time out sound
          }
        }, 1000);
      }
      //function for random position of randomCreature function
      function setRandomPosition(object, positionsArray) {
        if (stop) return;

        let randomPosition;
        let randomIndex;
        do {
          randomIndex = Math.floor(Math.random() * positionsArray.length);
          randomPosition = positionsArray[randomIndex];
        } while (
          randomPosition.equals(axolotl.position) ||
          randomPosition.equals(jellyfish.position)
        );

        object.position.copy(randomPosition);
      }

      // Random between 'axolotl' and 'jellyfish' to pop up in scene
      function randomCreature() {
        if (stop) return;

        scene.remove(jellyfish);
        scene.remove(axolotl);

        // Random number between 1-6
        let randomCreatureIndex = Math.floor(Math.random() * 6) + 1;

        // if number === 1 or === 2 then add jellyfish to scene
        if (randomCreatureIndex === 1 || randomCreatureIndex === 2) {
          scene.add(jellyfish);
          setRandomPosition(jellyfish, fixedPositionsJellyfish);
        }

        // if number === 3 or === 4 or === 5 or === 6 then add axolotl to scene
        else {
          scene.add(axolotl);
          setRandomPosition(axolotl, fixedPositionsAxolotl);
        }
      }

      // Load 'axoloth.gltf' to be ready to use in scene
      const gltfLoader = new GLTFLoader();
      gltfLoader.load("axolotl.gltf", (gltf) => {
        axolotl = gltf.scene;
        //Access into child of the model
        axolotl.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true; 
          }
        });
      });

      // Load 'jellyfish.gltf' to be ready to use in scene
      gltfLoader.load("jellyfish.gltf", (gltf) => {
        jellyfish = gltf.scene;
        const originalMaterials = [];
        //Access into child of the model
        jellyfish.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
          }
        });
      });

      // Load 'hand.gltf' to be ready to use in scene
      gltfLoader.load("hand.gltf", (gltf) => {
        hand = gltf.scene;

        // Create an array to store original materials
        const originalMaterials = [];

        // Create a TextureLoader for handling embedded textures
        const textureLoader = new TextureLoader();

        // Traverse the hand model to store original materials and apply the appropriate material
        hand.traverse((child) => {
          if (child.isMesh) {
            // Store original material
            originalMaterials.push(child.material.clone());

            // Check if the child has a texture
            if (child.material.map) {
              // If the child has a texture, create a new material with both the texture and Blinn-Phong properties
              const blinnPhongMaterialWithTexture = new MeshPhongMaterial({
                map: child.material.map, // Preserve the original texture
                shininess: 15, // Adjust shininess
                specular: 0x888888, // Adjust specular color
              });

              // Apply the new material to the child
              child.material = blinnPhongMaterialWithTexture;
            } else {
              // If the child doesn't have a texture, create a regular Blinn-Phong material
              const blinnPhongMaterial = new MeshPhongMaterial({
                color: child.material.color.clone(), // Preserve the original color
                shininess: 15, // Adjust shininess
                specular: 0x888888, // Adjust specular color
              });

              // Apply the Blinn-Phong material to the child
              child.material = blinnPhongMaterial;
            }
          }
        });

        scene.add(hand);
        hand.visible = false; // Initially hide 'hand'
      });

      // Load 'shark_ham_1.gltf' to be ready to use in scene
      gltfLoader.load("shark_ham_1.gltf", (gltf) => {
        shark_ham_1 = gltf.scene;
        shark_ham_1.visible = false; // Initially hide 'shark_ham_1'

        // Create an array to store original materials
        const originalMaterials = [];

        // Create a TextureLoader for handling embedded textures
        const textureLoader = new TextureLoader();

        // Traverse the hand model to store original materials and apply the appropriate material
        shark_ham_1.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            originalMaterials.push(child.material.clone());

            // Check if the child has a texture
            if (child.material.map) {
              // If the child has a texture, create a new material with both the texture and Blinn-Phong properties
              const blinnPhongMaterialWithTexture = new MeshPhongMaterial({
                map: child.material.map, // Preserve the original texture
                shininess: 15, // Adjust shininess
                specular: 0x888888, // Adjust specular color
              });

              // Apply the new material to the child
              child.material = blinnPhongMaterialWithTexture;
            } else {
              // If the child doesn't have a texture, create a regular Blinn-Phong material
              const blinnPhongMaterial = new MeshPhongMaterial({
                color: child.material.color.clone(), // Preserve the original color
                shininess: 15, // Adjust shininess
                specular: 0x888888, // Adjust specular color
              });

              // Apply the Blinn-Phong material to the child
              child.material = blinnPhongMaterial;
            }
          }
        });
        scene.add(shark_ham_1);
      });

      // Load 'board.gltf' to be ready to use in scene
      gltfLoader.load("board.gltf", (gltf) => {
        board = gltf.scene;
        board.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        scene.add(board); //

        // compute the box that contains all the stuff
        const boardBox = new THREE.Box3().setFromObject(board);
        const boardBoxSize = boardBox.getSize(new THREE.Vector3()).length();
        const boardBoxCenter = boardBox.getCenter(new THREE.Vector3());
        const distance = boardBoxSize;

        // setting camera to get the wanted view
        camera.position.set(-3, 36, 20);
        camera.lookAt(-2, 0, -35);
        camera.far = distance * 1000;
        camera.updateProjectionMatrix();
      });

      // Create raycaster for 'axolotl' and 'jelyfish'
      const raycasterAxolotl = new THREE.Raycaster();
      const raycasterJellyfish = new THREE.Raycaster();

      // Create mouse for set mouse position
      const mouse = new THREE.Vector2();

      // Swap 'hand' and 'shark_ham_1' to show and dissapear accordingly
      function showAndHideShark(position) {
        if (shark_ham_1.visible) {
          shark_ham_1.visible = false;
          hand.visible = true;
        } else {
          shark_ham_1.visible = true;
          shark_ham_1.position.copy(position);
          hand.visible = false;
          setTimeout(() => {
            shark_ham_1.visible = false;
            hand.visible = true;
          }, 100); // delay before removing 'shark_ham_1'
        }
      }

      // Store 'axolotl' position
      let lastAxolotlPosition = new THREE.Vector3();
      function onClickAxolotl(event) {
        if (stop) return;

        // change mouse position to normalized device coordinates
        mouse.x = (event.clientX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / canvas.clientHeight) * 2 + 1;

        // set raycaster with mouse position
        raycasterAxolotl.setFromCamera(mouse, camera);
        // intersect with all 'axolotl' object in the scene
        const intersectsAxolotl = raycasterAxolotl.intersectObjects(
          [axolotl],
          true
        );
        // Check if have intersect object
        for (const intersect of intersectsAxolotl) {
          // store object that raycaster intersected
          lastAxolotlPosition.copy(intersect.point);

          // Check if object in the scene is 'axolotl'
          if (scene.children.includes(axolotl)) {
            // Sync motion of 'axolotl' with 'hand' and 'shark_ham_1' when click
            showAndHideShark(lastAxolotlPosition);
            // Do every 0.05 seconds
            setTimeout(() => {
              playSound();
              scene.remove(axolotl);
              score++;
              guiParams.score = score;
            }, 50); // delay before removing 'axolotl'
            event.stopPropagation();
            return;
          }
        }
      }

      // store 'jellyfish' position
      let lastJellyfishPosition = new THREE.Vector3();
      function onClickJellyfish(event) {
        // change mouse position to normalized device coordinates
        mouse.x = (event.clientX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / canvas.clientHeight) * 2 + 1;

        // set raycaster with mouse position
        raycasterJellyfish.setFromCamera(mouse, camera);

        // intersect with all 'jellyfish' object in scene
        const intersectsJellyfish = raycasterJellyfish.intersectObjects(
          [jellyfish],
          true
        );

        // check if have intersected object
        for (const intersect of intersectsJellyfish) {
          // store object that raycaster intersected
          lastJellyfishPosition.copy(intersect.point);

          // Check if the object in the scene is 'jellyfish'
          if (scene.children.includes(jellyfish)) {
            // Sync motion of 'jellyfish' with 'hand' and 'shark_ham_1' when click
            showAndHideShark(lastJellyfishPosition);
            // Do every 0.05 seconds
            setTimeout(() => {
              playSound();
              scene.remove(jellyfish);
              guiParams.heart--;
              if (guiParams.heart >= 0) {
                // Change the heart icon based on the remaining hearts
                const heartIcon = document.querySelector(
                  `.heart-icon:nth-child(${guiParams.heart + 1})`
                );
                heartIcon.style.backgroundImage =
                  "url(https://clipart-library.com/img1/1672270.png)";
                heartIcon.style.backgroundSize = "14px 13.5px";
              }
              // if heart === 0 then stop playig
              if (guiParams.heart === 0) {
                stop = true;
                gameO.currentTime = 0; // Reset currentTime to 0
                gameO.play(); // Trigger game over sound
                gameO.volume = 0.5;
                popup.style.display = "block";
              }
            }, 50); // delay before removing 'jellyfish'
            event.stopPropagation();
            return;
          }
        }
      }

      canvas.addEventListener("click", (event) => {
        if (event.target === canvas) {
          // Check for clicking only in canvas
          onClickAxolotl(event);
          onClickJellyfish(event);
        }
      });

      // Do randomCreature() every 0.65 seconds
      setInterval(() => {
        randomCreature();
      }, 650);

      // resize canvas to display size
      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      //render time
      function render(time) {
        time *= 0.001; // convert to seconds

        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        renderer.render(scene, camera);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    }

    main();
  </script>
</html>
